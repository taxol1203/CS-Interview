# 공통 프로젝트 관련

자소서에 공통 프로젝트(2학기 1번째 프로젝트)를 작성했다는 가정입니다.

Q. SSAFY에서 본인이 [Web RTC, Web 디자인(SNS), 웹 IoT 등] 프로젝트를 했다고 하는데 어떤 (기술적인) 역할을 하셨나요
A. FE 파트를 총감독하면서 Vue.js와, vue3와 호환이 되는 element-plus를 프레임워크를 사용하여 개발했습니다.  
좀 더 디테일한 부분으로는 회원가입 정보 유효성 검사를 위한 정규표현식 설계, 채팅 메세지의 날짜 구분, Video&Chat 내용을 Swagger를 통해 받은 뒤 Front에 나타내는 것, 전체적인 layout 설계, SPA, Transition을 활용한 화면 애니메이션 효과 등을 구현했습니다.  
비개발적인 부분으로는 Jira&Notion 관리 및 정리, UI/UX에 대한 고민(단순히 입력창에서 엔터를 치면 다음 입력바로 넘어가는 것 등 유저가 당연하다고 여길만한 다양한 부분을 챙겼습니다.) 등을 진행했습니다.

Q. ~~한 역할을 하셨다고 했는데 해당 부분에서 알고리즘을 사용한 부분이 있을까요? 있다면 어떤 알고리즘이고 어떻게 구현했는지 간단하게 설명해주세요.
A. 가장 마지막에 온 채팅메시지가 언제 온 것인지 출력하는 부분에 대해 설명드리겠습니다.
우선 아무래도 FE를 전담해서 개발을 진행하다보니 흔히 백준 같은 사이트에서 사용하는 알고리즘은 사용할 일이 적었습니다.  
하지만 알고리즘이란 어떤 문제를 풀이하기 위한 계산 절차, 처리 과정의 순서를 의미한다고 생각합니다. 이런 의미로 설명드리겠습니다.  
채팅 메시지 자체를 swagger를 통해 받은 후, 해당 채팅 메시지가 어느 채팅방에 속한지를 구분한 뒤, 가장 마지막에 받은 메시지 정보 중 시간 정보를 분리합니다. 분리한 시간 정보와 현재 시간 정보를 구분하여 24시간 이내이면 3 시간 전 처럼 표기하여주고 그렇지 않으면 연-월-일 의 정보로 출력하였습니다.

Q. ~~한 역할을 하셨다고 했는데, 어느정도로 했는지 알 수 있게 본인이 진행한 것 설명 부탁드립니다.
A. 앞서 말한 저의 역할들을 좀 더 구체화해서 말씀드리겠습니다.  
회원가입 부분을 개발할 때 이메일, 비밀번호 유효성 검사를 위한 정규표현식을 설계하였습니다.
해당 정규표현식을 통과하지 못했다면 다음 버튼을 비활성화 하고, 또 해당 입력창 하단에 붉은 글씨로 유저에게 실시간으로 현재 입력한 값이 부정확함을 인지시켜주어 유저의 혼동을 막았습니다. 반대로 정상 입력되었을 경우 비활성화된 버튼이 활성화되고, 붉은 안내 문구에서 녹색 안내 문구로 바꾸며 지금 올바른 절차로 진행하고 있음을 알려주었습니다.  
또한 placeholder를 활용하여 유저에게 상세히 안내를 함으로써 사전에 잘못 입력할 가능성을 낮추었습니다.
그 외에도 회원가입, 취소 버튼의 위치, 버튼의 색상, 입력 순서 등을 상세히 고려하며 UI/UX 적인 부분까지 꼼꼼히 고려하는 역할을 맡아 프로젝트를 마쳤습니다.

Q. ~~ 기술을 사용해보셨다고 하는데, 어떤 식으로 동작하는지 알고 있는게 있다면 간단한게 설명해주세요
A. Vue.js에 대해 설명드리겠습니다.  
우선 웹이 실행되면 public 폴더 안의 index.html이 실행되고 main.js가 실행됩니다. main.js가 실행되면서 app.vue 인스턴스가 생깁니다. 제 프로젝트에선 SPA을 목표로 개발하였으므로 app.vue 안에 router를 활용하여 같은 page안에서 화면이 전환될 수 있도록 구성하였습니다. router와 생성된 component들을 활용하여 원하는 페이지 이동 등을 구현하였습니다.

---

# 디자인 패턴

```
디자인 패턴(Design Pattern): 프로그램 개발에서 자주 나타나는 과제를 해결하기 위한 방법 중 하나. 과거의 SW 개발 과정에서 발견된 설계의 노하우를 축적하여 이름을 붙여, 이후에 재이용하기 좋은 형태로 특정의 규약을 묶어서 정리한 것.
```

- 목적  
  SW 재사용성, 호환성, 유지 보수성을 보장

- 특징  
  디자인 패턴은 아이디어이다. 특정한 구현이 아니다.  
  프로젝트에 항상 적용해야하는 것은 아니지만 추후 재사용, 호환, 유지 보수 시 발생하는 문제 해결을 예방하기 위해 패턴을 만들어 둔 것이다.

- 원칙: SOLID

  1. Single Responsibility Principle  
     하나의 클래스는 하나의 역할만 해야 한다.
  2. Open-Close Principle
     확장(상속)에는 열려있고, 수정에는 닫혀 있어야 함.
  3. Liskov Substitution Principle  
     자식이 부모의 자리에 항상 교체될 수 있어야 함.
  4. Interface Segregation Principle
     인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야함.
  5. Dependency Inversion Property  
     상위 모듈이 하위 모듈에 의존하면 안됨  
     둘 다 추상황에 의존하며, 세부 사항에 의존하면 안 됨.

- 분류 (중요)  
  `3 가지 목적을 이해해야 한다.`
  1. 생성 패턴(Creational): 객체의 생성 방식 결정  
     Class-creational patterns, Object-creational patterns  
     ex) DBConnection을 관리하는 Instance를 하나로 만들 수 있도록 제한하여, 불필요한 연결을 막는다.
  2. 구조 패턴(Structure): 객체 간의 관계를 조직  
     ex) 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해서 새로운 클래스를 만들어서 연결시킬 수 있도록 함.
  3. 행위 패턴(Behavioral): 객체의 행위를 조직, 관리, 연합  
     ex) 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언하여, 상속 시 이를 필수로 구현하도록 함.

## Singletone

```
싱글톤 패턴(Singleton Pattern): 애플리케이션이 시작될 때, 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고 해당 메모리에 인스턴스를 만들어 사용하는 패턴이다. 즉, 싱글톤 패턴은 '하나'의 인스턴스만 생성하여 사용하는 디자인 패턴이다.
```

- 추가 설명

  - 인스턴스가 필요할 때, 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것이다.
  - 생성자가 여러 번 호출되도, 실제로 생성되는 객체는 하나이며 최초로 생성된 이후에 호출된 생성자는 이미 생성한 객체를 반환시키도록 만드는 것이다.
  - (java에서는 생성자를 private으로 선언해 다른 곳에서 생성하지 못하도록 만들고, getInstance() 메소드를 통해 받아서 사용하도록 구현한다)

- 목적  
   먼저, 객체는 생성할 때마다 메모리 영역을 할당받아야 한다. 하지만 한 번의 new만을 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.  
   또한 싱글톤으로 구현한 인스턴스는 전역이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.

- 주용도

  - 주로 공통된 객체를 여러 개 생성해서 사용해야하는 상황
    ex) DB에서 커넥션 풀, 스레드 풀, 캐시, 로그 기록 객체 등
  - 안드로이드 앱: 각 액티비티들이나, 클래스마다 주요 클래스들을 하나하나 전달하는게 번거롭기 때문에 싱글톤 클래스를 만들어 어디서든 접근하도록 설계
  - 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 때

- 단점
  - 객체 지향 설계 원칙 중 `개방-폐쇠 원칙`이 있는데, 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스들 간의 결합도가 높아지게 되는데, 이 때 개방-폐쇄 원칙에 위배된다.
  - 결합도가 높아지면 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제점이 발생한다.
  - 멀티 스레드 환경에서 도익화 처리를 하지 않읐을 때, 인스턴스가 2개가 생성되는 문제도 발생할 수 있다.

따라서 반드시 싱글톤이 필요한 상황이 아니면 지양하는 것을 권장함.

# Web

## JWT(JSON Web Token)

```
JSON 웹 토큰(JSON Web Token): 선택적 서명 및 선택적 암호화를 사용하여 데이터를 만들기 위한 인터넷 표준이다. 즉, JWT는 웹표준(RFC 7519)으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적인 방식으로 정보를 안정성 있게 전달해줍니다. payload는 몇몇 클레임(claim) 표명(assert)을 처리하는 JSON을 보관하고 있다.
```

- 구성요소
  JWT는 .을 구분자로 3가지의 문자열로 구성되어 있습니다.  
   aaaa.bbbbb.ccccc의 구조로 앞부터 헤더(header), 내용(payload), 서명(signature)로 구성됩니다.
  1. Header  
     헤더는 typ와 alg 두 가지의 정보를 지니고 있습니다. - typ: 토큰의 타입을 지정합니다. JWT이기에 "JWT"라는 값이 들어갑니다. - alg: 해싱 알고리즘을 지정합니다. 기본적으로 HMAC, SHA256, RSA가 사용되면 토큰을 검증할 때 사용되는 signature 부분에서 사용됩니다.

```
{
  "typ" : "JWT",
  "alg" : "HS256"
  }
```

- 2. 정보(Payload)
  - payload 부분에는 토큰을 담을 정보가 들어있다.
  - 정보의 한 조각을 클레임(Claim)이라고 부르고, 이는 name/value의 한 쌍으로 이뤄져있다.
  - 토큰에는 여러 개의 클레임들을 넣을 수 있지만 너무 많아질 경우 토큰의 길이가 길어질 수 있다.
  - 클레임의 종류는 크게 3 분류로 나누어 진다.
    1. 등록된(registered) 클레임: 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위해 이름이 이미 정해진 클레임들. 등록된 클레임의 사용은 모두 선택적(optional)이며, 이에 포함된 클레임 이름들은 다음과 같다.
    - iss: 토큰 발급자(issuer)
    - sub: 토큰 제목(subject)
    - aud: 토큰 대상자(audience)
    - exp: 토큰의 만료시간(expiration), 시간은 NumericDate 형식으로 되어있어야 하며 언제나 현재 시간보다 이후로 설정되어 있어야 합니다.
    - nbf: Not Before을 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 NumericDate 형식으로 날짜를 지정하며, 이 날짜가 지나기 전까지는 토큰이 처리되지 않습니다.
    - iat: 토큰이 발급된 시간(issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있습니다.
    - jti: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위해 사용됩니다. 일회용 토큰에 사용하면 유용합니다.
    2. 공개(public) 클레임: 공개 클레임들은 충돌이 방지된(collision-resistant) 이름을 가지고 있어야 합니다. 충돌을 방지하기 위해선, 클레임 이름을 URI 형식으로 짓습니다.
       `{ "https://chup.tistory.com/jwt_claims/is_admin" : true }`
    3. 비공개(private) 클레임: 등록된 클레임도 아니고, 공개된 클레임들도 아닙니다. 양 측간의(보통 클라이언트 <-> 서버) 합의 하에 사용되는 클레임 이름들입니다. 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때 유의해야 합니다.
- 3. 서명(signature)
  - 서명은 헤더의 인코딩 값과 정보의 인코딩 값을 합친 후 주어진 비밀키로 해쉬를 하여 생성합니다. 이렇게 만든 해쉬를 `base 64` 형태로 나타내게 됩니다.

### 로그인 인증 시 JWT 사용

- 유효기간이 짧은 토큰 사용 -> 사용자 입장에서 자주 로그인을 해야 함
- 유효기간이 긴 토큰 사용 -> 제 3자에게 토큰을 탈취당할 경우 보안 취약점이 발생
- 그 결과 Refresh Token을 사용

```
Refresh Token: Access Token과 똑같은 JWT이다. Access Token의 유효기간이 만료되었을 때, Refresh Token이 새로 발급해주는 열쇠가 된다. 예를 들어, Refresh Token의 유효기간은 1주, Access Token의 유효기간이 1시간이라고 한다면, 사용자는 Access Token으로 1시간 동안 API 요청을 하다가 시간이 만료되면 Refresh Token을 이용하여 새롭게 발급해줍니다. 이 방법 또한 Access Token이 탈취당한다 해도 정보가 유출이 되는 것을 막을 수 없지만, 더 짧은 유효기간 때문에 탈취되는 가능성이 적다는 점을 이용한 것입니다. Refresh Token도 탈취 될 가능성이 있기 때문에 적절한 유효기간 설정이 필요합니다.
```

## HTTP status code

- 정의

  - 클라이언트가 서버에게 요청을 보낼 때 그 요청의 결과가 어떻게 되었는지를 알려주는 것.

- 종류

  1. 10x: 정보 확인
  2. 20x: 통신 성공
  3. 30x: 리다이렉트
  4. 40x: 클라이언트 오류
  5. 50x: 서버 오류

- 200 번대 의미

  - 200 OK: 요청 성공(GET)
  - 201 Create: 생성 성공(POST)
  - 202 Accepted: 요청 접수 O, 리소스 처리 X
  - 생략

- 300 번대 의미

  - 300 Multiple Choice: 요청 URI에 여러 리소스가 존재
  - 생략

- 400 번대 의미

  - 400 Bad Request: API에서 정의되지 않은 요청 들어옴
  - 401 Unauthorized: 인증 오류
  - 403 Forbidden: 권한 밖의 접근 시도
  - 404 Not Found: 요청 URI에 대한 리소스 존재X
  - 생략

- 500 번대 의미
  - 500 Internal Server Error: 서버 내부 오류
  - 502 Bad Gateway: 게이트 웨이 오류
  - 생략

해결방안 등

---

# QnA

---

# 참고

[디자인패턴 개요](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Design%20Pattern/%5BDesign%20Pattern%5D%20Overview.md)  
[싱글톤 패턴](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Design%20Pattern/Singleton%20Pattern.md)  
[JWT](<https://github.com/gyoogle/tech-interview-for-developer/blob/master/Web/JWT(JSON%20Web%20Token).md>)  
[HTTP Status Code](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Web/HTTP%20status%20code.md)
