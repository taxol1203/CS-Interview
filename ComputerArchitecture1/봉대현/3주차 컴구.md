# 3주차 컴구

# 리틀 엔디안, 빅엔디안

비트와 바이트 

- 컴퓨터는 모든 데이터를 2진수로 표현하고 처리한다.
- 비트 : 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위(0,1)만 저장
- 바이트 : 비트가 8개모여서 구성, 한 문자를 표현할 수 있는 최소 단위

## 엔디안 이란?

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻한다. (바이트를 배열하는 방법을 특히 바이트 순서라 한다.)

## 리틀 엔디안 vs 빅 엔디안

- Big-endian : 보통 큰 단위가 앞에 나옴 , **최상위 바이트(MSB)**부터 차례로 저장하는 방식
- Little-endian : 작은 단위가 앞에 나옴, **최 하위 바이트(LSB)**부터 차례로 저장
- Middle-endian : 두 경우에 속하지 않거나 둘을 모두 지원하는 것

### 예시

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled.png](computer/Untitled.png)

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%201.png](computer/Untitled%201.png)

빅 엔디언 과 리틀 엔디언

- 빅 엔디언 : 높은 주소 —— 낮은 주소
- 리틀 엔디언 : 낮은 주소 ——- 높은 주소

### 장단점

- 빅엔디언 :
    - 소프트웨어의 디버그를 편하게 해주는 경향,
    - 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기가 쉽다는 장점을 가지고 있습니다.
    - 데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합합니다.
    - 네트워크를 통해 데이터를 전송할 때에는 빅 엔디안 방식이 사용됩니다.
- 리틀 엔디언 :
    - 대부분의 인텔 CPU 계열에서는 이 방식으로 데이터를 저장합니다. →why??
    - 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없다는 장점
    - 물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안 방식이 더 효율적

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%202.png](computer/Untitled%202.png)

[https://jhnyang.tistory.com/226](https://jhnyang.tistory.com/226)

# 비트연산

## 1의 보수

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%203.png](computer/Untitled%203.png)

- NOT 연산만으로 표현
- +0과 -0이 따로 존재하는 문제점을 가집니다

## 2의 보수

- 1의 보수의 문제를 해결하기 위해 고안
- 컴퓨터가 음수를 저장하기 위해 사용하는 방법 중 하나
- 맨 앞의 비트는 부호 비트로 사용. 0이면 양수 1이면 음수

    ![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%204.png](computer/Untitled%204.png)

- 비트연산자 NOT을 한다음 1을 더해주면 끝!

# 프로시저 호출 과정

## 프로시저

- 제공되는 인수에 따라서 특정한 작업을 수행하는 서브 루틴.
- 프로시저는 지정된 작업 외의 다른 것은 아무 것에도 영향을 주어서는 안된다.

## 프로시저 호출 후 실행 6단계

1. 프로시저가 접근할 수 있는 곳에 인수를 넣는다 ($a0~$a3)
2. 프로시저에 제어를 넘긴다.
3. 프로시저가 필요로 하는 메모리 자원을 획득한다.
4. 필요한 작업을 수행한다.
5. 호출한 프로그램이 접근 할 수 있는 장소에 결과 값을 넣는다. ($v0~$v1)
6. 프로시저는 프로그램 내의 여러 곳에서 호출될 수 있으므로 원래 위치로 제어를 돌려준다. ($ra)

[https://hoooooooooooooop.tistory.com/entry/computer-architecture2-8](https://hoooooooooooooop.tistory.com/entry/computer-architecture2-8)

[https://gusdnd852.tistory.com/244](https://gusdnd852.tistory.com/244)

# 메모리 레이아웃

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%205.png](computer/Untitled%205.png)

- c언어를 하지 않아도 이렇게 대부분 저장되니 다른 언어들도 참고
- 밑에서 부터 순서대로 적치
- 스택 : 높은 주소로 부터 낮은 주소순으로 적치

## 프로그램 코드

- 절대 바뀌지 않는 불변 영역
- 읽기는 가능해도 수정은 불가능

### text 영역

- 코드 자체가 기록되는 영역
- 선언된 함수들이 저장되는 영역

### init(const) 영역

- Read Only
- 절대 변경될 수 없는 상수 "그 자체"가 기록
- const 인자가 붙은 애들은 변수를 fixed시켜서 마치  상수처럼 사용할 수 있는 것에 불과함
- init영역에서는 그 중에서도 후자인 변수를 초기화할 때 쓰이는 값들"만" 저장됩니다.

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%206.png](computer/Untitled%206.png)

- 초기화 시킬때 사용했던 상수들만 init영역에 저장 ⇒ 5, 3.14가 저장

### rodata영역

- read only data 영역
- init과 같이 리터럴 타입만 저장 + init영역에서 쓰이지 않았던 부분들만 모두 저장

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%207.png](computer/Untitled%207.png)

- 초기화 구문을 제외하고 모조리 기록

## 전역, 정적 자료

static, global 변수들은 여기에다가 저장

전역변수와 정적변수들의 특징은 프로그램이 열릴 때 시작해서 프로그램이 닫힐때 까지 생존

RW(Read Write) 영역

### data영역

이미 초기화된, **이니셜라이징이 완료된 변수**들만 여기에 저장

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%208.png](computer/Untitled%208.png)

- start_num 은 초기화되었으니 data영역에 저장된다.
- main함수를 실행하기 직전에 init영역을 확인하고 5의 주소를 확인하여서 그값을 준다.

### bass영역

Block Started by Symbol의 줄임말 

초기화 되지 않은 전역변수와 정적 변수를 저장

자신의 짝이 없기 때문에 init영역을 확인하지 않고 바로 0으로 초기화

→ 정적변수와 전역변수가 왜 바로 0으로 초기회된 이유

## 스택

자동 변수들, 지역 변수들이 저장되는 곳

자동변수나 지역변수들은 모두 런타임에 생성되었다가 소멸됩니다.

정적 바인딩이냐면 변수의 형태(자료형)이 컴파일 시간에 결정되기 때문

메모리 정적 할당

## 힙

메모리 동적 할당으로 저장된 데이터들

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%209.png](computer/Untitled%209.png)

malloc함수를 호출하면 메모리 주소를 리턴해주지요? 그 메모리가 바로 힙입니다.

[https://m.blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=justkukaro&logNo=220681279377&categoryNo=9&proxyReferer=](https://m.blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=justkukaro&logNo=220681279377&categoryNo=9&proxyReferer=)

# CPU 레지스터

중앙처리장치(CPU) 내에 위치한 기억장치로 많은 수의 레지스터를 CPU내에 포함시키는 것은 어렵기 때문에 특수목적용 레지스터들과 몇몇 일반 목적용 레지스터만 존재한다.

## CPU

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%2010.png](computer/Untitled%2010.png)

구성요소 → 제어장치, 연산 장치, 레지스터

제어장치가 중요

## 대표적인 레지스터의 종류

- PC : 다음 인출될 명령어의 주소를 가지고 있는 레지스터
- AC : 연산 결과 데이터를 일시적으로 저장하는 레지스터
- IR : 가장 최근에 인출된 명령어가 저장되어 있는 레지스터
- SR : 현재 CPU의 상태를 가지고 있는 레지스터
- MAR  : PC에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터
- MBR : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터

## 캐시와 레지스터의 차이

- 공통점 : 어떤 명령어나 데이터를 저장해두는 저장공간
- 차이점 :
    - 캐시는 CPU와 별도로 있는 공간이며 , 메인 메모리와 cpu간의 속도 차이를 극복하기 위한 것
    - 레지스터는 cpu안에서 연산을 처리하기 위하여 데이터를 저장하는 공간

# C프로그램에서 코드로 실행되는 과정

![3%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8F%E1%85%A5%E1%86%B7%E1%84%80%E1%85%AE%204f7e9f52d30e4b02988681fac3ae8d38/Untitled%2011.png](computer/Untitled%2011.png)

원본 소스 코드(hello.c) -(전처리)-> 전 처리 파일(hello.i) -(컴파일)-> 어셈블리어 파일(hello.s) -(어셈블)-> 바이너리 파일(hello.o) -(링크)-> 실행 파일

## 전처리과정

1. 헤더파일 삽입
2. 매크로 치환 및 적용
3. 주석된거 없애기

## 컴파일 과정

전처리가 끝난 .i 파일을 컴파일 하면 .s 어셈블리 파일 만들어짐

## 어셈블 과정

어셈블러에 의해 기계어로 어셈블됩니다.

어셈블러에 의해 생성되는 목적코드(hello.o)파일은 어셈블된 프로그램의 명령어와 데이터가 들어있는 바이너리 포맷 구조를 가지게됨

### ELF 바이너리 포맷

링커가 여러개의 바이너리 파일을 하나의 실행 파일로 묶기 위해서 각 바이너리의 정보를 효과적으로 파악하기 위해서(명렁어와 데이터의 범위 등) 일정한 규칙을 갖게 형식화

## 링킹 과정

표준 C라이브러리, 사용자 라이브러리들을 링크 합니다.

[https://gracefulprograming.tistory.com/16](https://gracefulprograming.tistory.com/16)

# 질문 후보

1. 리틀 엔디안이 무었이며 , 리틀 엔디안을 어디다가 쓰면 좋은가요??
- 바이트 순서에 따라 빅 , 리틀 엔디안으로 나눕니다. 리틀 엔디안은 LSB비트부터 채우는 방식입니다. 즉 낮은 주소의 값부터 채웁니다.
- 리틀 엔디안은 물리적으로 데이터를 조작하거나 산술 연산을 수행할때에 빅엔디언보다 방식이 효율적입니다. 계산기의 덧셈를 컴퓨터가 계산한다고 예시를 들겠습니다. 1234+5678을 더하면  오른쪽부터 계산을 해주고 10이상이면 carry가 생겨서 1을 다음자리수에 올려주어야되죠
CPU회로상에서도 위와 같이 해줘야된다. 빅엔디언이면 34 12 +78 56으로 계산해야되서 더욱 복잡해진다 이에 비해 리틀엔디언은 12 34 + 56 78을 하여서 자리 올림수를 미리 판단하여서 다음 숫자를 계산할 수 있어서 효율적이다.

1. CPU레지스터에 대해서 설명해주시고 캐시와 레지스터의 차이를 설명해주세요
- CPU레지스터는 중앙처리장치(CPU) 내에 위치한 기억장치로 많은 수의 레지스터를 CPU내에 포함시키는 것은 어렵기 때문에 특수목적용 레지스터들과 몇몇 일반 목적용 레지스터만 존재합니다. 그리고 캐시와 레지스터의 공통점으로는 둘다 어떤 명령어나 데이터를 저장해두는 저장공간입니다. 차이점으로는 캐시는 CPU 내부에 없고 메인 메모리와 cpu간의 속도차이를 줄여주기 위함이고 레지스터는  cpu안에서 연산을 처리하기 위하여 데이터를 저장하는 공간이라는 차이가 있습니다.

1. c프로그램에서 코드로 실행되는 과정을 설명하세요

    원본 소스 코드(hello.c) -(전처리): 주석처리, 헤더파일, 매크로 치환 및 적용(#define)-> 전 처리 파일(hello.i) -(컴파일)-> 어셈블리어 파일(hello.s) -(어셈블)-> 바이너리 파일(hello.o) -(링크)-> 실행 파일

    꼬리 질문 후보

    1. 전처리과정에서는 대체로 무엇을 하는지 아시나요??
        1. 주석처리, 헤더파일 삽입, 매크로 치환 및 적용을 합니다.
    2. 왜 바이너리 포맷의 구조를 가지게 만들죠?

        링커가 여러개의 바이너리 파일을 하나의 실행 파일로 묶기 위해서 각 바이너리의 정보를 효과적으로 파악하기 위해서(명렁어와 데이터의 범위 등) 일정한 규칙을 갖게 형식화