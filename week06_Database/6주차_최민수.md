# 데이터 베이스

## 데이터베이스란? 왜 사용할까

- DB를 사용하기 이전에 발생하는 문제
  - DB를 사용하기 전에는 파일 시스템을 이용하여 관리하였는데 이 경우에는 데이터 종속성, 중복성, 무결성 문제가 발생함.

```
데이터 종속성: 응용 프로그램과 데이터 간의 상호 의존 관계. 데이터의 구성 방법이나 접근 방법을 변경할 때 이를 기초로 한 응용 프로그램도 같이 변경해야 하는 특징.
```

```
데이터 중복성: 응용 프로그램 A가 필요로 하는 데이터 x를 응용 프로그램 B도 필요로하는 경우, x를 복사하여 사용하는 경우가 있다. 이는 결과적으로 같은 파일 시스템 내에 내용이 같은 x라는 데이터가 2개 이상 존재하는 결과를 초래한다. 이와 같이 한 시스템 내에 내용이 같은 데이터가 중복되게 저장 관리되는 것을 말한다.
```

```
데이터 무결성: 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다. 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지하며 개체 무결성, 참조 무결성, 도메인 무결성, 무결성 규칙 4가지 종류로 구분한다.
```

### 참조 무결성이란?

```
참조 무결성(Referential Integrity): 관계형 데이터베이스 모델에서 참조 무결성은 참조 관계에 있는 두 데이터가 항상 일관된 값을 갖도록 유지되는 것을 말한다. 사용자의 실수로 관련 데이터가 삭제되거나 수정되는 것을 막아 준다.
```

참조 무결성 제약 조건: 기본 테이블에서 일치하는 필드가 기본키(PK)이거나 고유 인덱스를 갖고 있거나 관련 필드의 데이터 형식이 같아야 한다.

### 데이터의 특징

1. 독립성

- 물리적 독립성: DB 사이즈를 늘리거나 줄일 때 관련된 응용 프로그램을 수정할 필요가 없다.
- 논리적 독립성: 논리적인 구조를 가지므로 응용 프로그램의 요구를 만족시킬 수 있다.

2. 무결성

- 여러 경로를 통해 잘못된 데이터가 발생하는 경우를 방지하는 기능(데이터의 유효성 검사)

3. 보안성

- 권한이 있는 사용자들만 자원에 접근할 수 있도록 설정

4. 일관성

- 연관된 정보를 논리적인 구조로 관리함(어떤 데이터를 변경했을 때 나머지 데이터와 일치하지 않는 불일치성을 배제함)

5. 중복 최소화

- 데이터를 통합 관리함으로써 자료의 중복과 데이터의 중복 문제를 해결할 수 있다.

## DBMS

```
DBMS: 다수의 사용자들이 컴퓨터에 수록된 수 많은 자료들을 쉽고 빠르게 추가, 수정, 삭제할 수 있도록 해주는 시스템. 대표적으로 구성, 조작, 제어 총 3가지 기능을 제공한다.
```

사용하는 목적: DB 내의 정보를 검색하거나 정보를 저장하기 편리하고 효율적인 환경을 제공하는 것

대표적인 3가지 기능

1. 구성

- DB에 저장될 자료의 구조와 응용 프로그램이 그것을 이용하는 방식을 정의(레코드 구조, 데이터 모형, 물리적 구조 등)

2. 조작

- 사용자 도구에 따라 DB에 저장된 자료를 검색, 갱신, 삽입, 삭제할 수 있도록 지원

3. 제어

- DB의 내용에 대한 일관성, 중복제거, 접근제어에 대한 기능을 지원

## Key

기본키(Primary Key)

- 테이블에서 각 Row(행)을 유일하게 구분하는 Column-key
- 후보키 중 특별히 선정된 메인키
- 중복된 값, Null 값을 가질 수 없다.

후보키(Candidate Key)

- 튜플을 유일하게 식별하는 속성들의 부분 집합
- 기본키로 사용할 수 있는 속성
- 유일성, 최소성 모두 만족

대체키(Alternate Key)

- 후보키가 둘 이상일 때 기본키 제외한 나머지 후보키

슈퍼키(Super Key)

- 한 릴레이션 내에 있는 속성들의 집합으로 구성
- 모든 튜플 중 슈퍼키로 구성된 속성 집합과 동일한 값 나타나지 않음
- 유일성을 만족하지만, 최소성을 만족하지 못함

외래키(Foreign Key)

- 다른 릴레이션의 기본키를 참조하는 속성이다.
- 외래키로 지정되면, 참조 릴레이션 기본키에 있는 값만 입력 가능

## 인덱스

```
Index(색인): 말 그대로 색인. DB에선 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만든다. 이를 통해 모든 데이터를 검색해서 찾는 것보다 빠르게 찾을 수 있다.
```

### 인덱스 자료 구조

1. B-Tree

- 일반적으로 사용되는 알고리즘으로 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.

2. Hash

- 컬럼의 값으로 해시 값을 계산해서 인덱스하는 알고리즘으로 매우 빠른 검색속도를 가지고 있다. 하지만 값을 변형해서 인덱싱하므로 값의 일부만으로 검색할 때는 Hash를 사용할 수 없다.

Select 질의 조건에 부등호(<>)가 포함되는데 Hash 연산은 부등호 연산의 경우에 B-Tree보다 문제가 있다.(왜?)

### 클러스터

인덱스에서 클러스터는 물리적으로 인접한 장소에 저장되어 있는 데이터들을 묶어서 저장하는 형태이다.  
클러스터 인덱스는 Primary Key에 의해 레코드 저장 위치가 결정된다. 따라서 키를 신중하게 결정하고 사용해야 한다.

### 성능, 고려해야할 사항

인덱스를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가된다.  
INSERT는 인덱스에 대한 데이터를 추가해야하고  
DELETE는 인덱스에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시로 남게 된다.  
따라서 row 수는 그대로이므로 실제 데이터에 비해 허수 데이터가 많이 존재할 수 있다.

## 트랜잭션

```
트랜잭션(Transaction): 작업의 완전성을 보장해주는 것. 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 사용자 입장에서는 작업의 논리적 단위로 이해할 수 있고, 시스템 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.
```

### 트랜잭션과 Lock

서로 비슷한 개념 같지만 사실 Lock은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능이다.

- Lock: 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
- 트랜잭션: 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것.

### 트랜잭션의 특성

트랜잭션은 ACID라는 4가지 특성을 만족해야 한다.

1. 원자성(Atomicity)

- 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생하지 않았을 경우에만 모든 작업이 수행되어야 한다.

2. 일관성(Consistenct)

- 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.

3. 고립성(Isolation)

- 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.

4. 지속성(Durability)

- 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 DB에 작업의 결과가 저장되어야 한다.

## Anomaly

```
이상 현상(Anomaly): 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 생기는 현상
```

이상의 종류

1. 삽입 이상(Insertion Anomaly)
2. 삭제 이상(Deletion Anomaly)
3. 갱신 이상(Update Anomaly)

```
삽입 이상: 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
```

```
삭제 이상: 테이플에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상
```

```
갱신 이상: 테이블에서 튜플에 있는 속성 값을 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상
```

## 정규화(Normalization)

```
정규화: 테이블 속성들이 상호 종속적 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정이다. 가능한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것이 목적이다.
```

제 1 정규화

- 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해하는 것  
  제 2 정규화
- 완전 함수 종속(기본키의 부분집합이 결정자가 되어선 안된다는 것)을 만족하도록 테이블을 분해하는 것
  제 3 정규화
- 이행적 종속을 없애도록 테이블을 분해하는 것
  BCNF 정규화
- 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
  제 4 정규화
- 다치 종속 제거
  제 5 정규화
- 조인 속성 이용

암기팁: 도부이결다조

### 함수적 종속

A가 B의 결정자이면, B는 A에 함수적 종속이다.  
풀어 말하면 A의 값을 알면 B의 값을 바로 식별할 수 있고, A의 값에 따라 B의 값이 달라지면 B는 A에 함수적 종속이라고 한다.

## 역정규화(Denormalization)

```
역정규화(Denormalization): 이전에 정규화된 DB에서 성능을 개선하기 위해 사용되는 전략이다. 일부 Write 성능의 손실을 감수하고 데이터를 묶거나 데이터의 복제 사본을 추가하여 DB의 Read 성능을 개선하려고 하는 시도이다.
```

## SQL(RDBMS) vs NOSQL

```
NoSQL: NoSQL DB는 전통적인 RDB보다 덜 제한적인 일관성 모델을 이용하는 데이터의 저장 및 검색을 위한 매커니즘을 제공한다. 다르게 말하면 기존 RDB가 갖고 있는 특성뿐만 아니라, 다른 특성들을 부가적으로 지원함. RDB의 ACID 특성을 제공하지 않는 대신 뛰어난 확장성, 성능 등의 특성을 가진다.
```

### NoSQL이 SQL과 다른점

- NoSQL은 스키마가 없다. 즉 데이터 관계와 정해진 규격이 없다.
- 관계 정의가 없어서 Join이 불가능하다
- 트랜잭션을 지원하지 않는다.
- 분산처리의 기능을 쉽게 제공한다
- 대부분의 NoSQL DB는 분산처리기능을 목적으로 생겼기 때문에 분선처리 기능을 자체 프레임워크에 포함하고 있다.

## 후보들

이번주에는 공부 안하셔도 되지만 알아 놓으면 좋은 것들
DB 락, ORM

---

## 질문

1. DB를 왜 사용할까?  
   A. DB를 사용하기 전에는 파일 시스템을 이용하여 관리하였는데 이 경우에는 데이터 종속성, 중복성, 무결성 문제가 발생함.

2. 클러스터의 개념

3. index 삽입, 삭제, 수정할 떄 일어나는 일

4. 참조 무결성이란 뭘까요

### 꼬리 질문
그렇다면 참조무결성이 없는 DB는 어떤 문제가 발생할까요?

트랜잭션을 사용하면 어떤 장점이 있을까요?

왜 데이터 중복이 발생할까요?

왜 XX DB를 사용했는지?

---

## 받은 피드백

답변이 맞는게 하나도 없다. SQL RDMBS의 특징은 스키마를 만들고 데이터 무결성을 보장하고, 무결성
NoSQL은 스키마가 없고, 제약조건이 없이 key-value pair로 넣는다.
비정형 데이터(사진, 영상)를 다룰 수도 있겠지만, 이게 핵심은 아니고 스키마가 없다.는 점

큰 장점 스키마가 없으니까, 막 집어넣으니까 스케일 업이 가능하다. 여러 머신에 분산해서 저장할 수 있다.
빅데이터 등을 수집하는데 적합하다.

B-Tree, Hash

논리적 탐구가 좋았따.

 역정규화 딱 들었을 때 모르겠다. 비유가 좀 햇갈렸다.



 ---

## 공부할 때 참고하시면 좋은 블로그들

[[정처기 요약] 데이터베이스](https://velog.io/@mrnglory/%EC%A0%95%EC%B2%98%EA%B8%B0-%EC%9A%94%EC%95%BD-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)  
[신입 프로그래머 기술(실무) 면접준비 [데이터베이스]](https://91ms.tistory.com/2)  
[[CS] 📕 데이터 베이스](https://velog.io/@soosungp33/CS-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4)
[정규화(이상, 함수적 종속, 정규화)](https://dotheright.tistory.com/107)
[NoSQL](https://www.samsungsds.com/kr/insights/1232564_4627.html)
