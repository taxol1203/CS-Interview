# 9주차 JAVA

## 객체지향

OOP는 프로그램을 설계하는 개념이자 방법론.  
프로그램을 객체라는 기본 단위로 나누고 이 객체들 간의 상호작용을 기본개념으로 한다.

장점

- 프로그램을 유연하고 변경하기 쉽게 만든다 -> 재사용성이 용이하다 -> 대규모 프로젝트에 적합하다.
- 프로그램의 개발, 유지가 용이하다.

단점

- 처리 속도가 느리다
- 객체에 따른 용량 증가
- 설계 단계에 시간이 많이 소요된다.

특징 4가지: 추상화, 캡슐화, 상속, 다형성

## 자바의 특징

1. OOP

- 상단에 기술

2. 자동 메모리 관리(GC)

- 하단에 기술

3. 운영체제에 독립적

- 개발환경, 배포환경이 달라도 다시 컴파일 할 필요없이 실행가능함. 그 이유는 Java는 JVM위에서 돌아가기 때문이다.

4. 멀티 스레드 지원

- 하나의 프로그램에서 여러 개의 쓰레드가 동시에 실행할 수 있는 환경을 지원한다. C/C++은 OS의 도움을 받아야한다.

5. 동적 로딩 지원(Dynamic Loading)

- 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 객체가 필요한 시점에 클래스를 동적 로딩하여 생성한다.
  장점
  - 클래스 일부 변경 시에도 다시 컴파일 하지 않아도 된다.
  - 비교적 적은 작업으로 처리할 수 있는 유연성을 동적 로딩이 제공
    단점
  - 그 때 그 때 메모리에서 불러오기 때문에 실행 속도가 정적 로딩에 비해 느림

## JAVA 컴파일 과정

들어가기 전

> Java는 JVM(Java Virtual Machine) 덕분에 OS에 독립적인 특징을 가지고 있습니다.

순서

1. 개발자가 Java 소스코드(.java)를 작성한다
2. Java Compiler가 Java 소스 파일을 compile 한다. 그 결과 Java 바이트 코드(.class)이 생성된다.  
   Java 바이트 코드는 아직 컴퓨터가 읽을 수 없고, JVM이 이해할 수 있는 코드이다.  
   바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져 있다.
3. 컴파일된 바이트 코드를 JVM의 클래스로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올립니다.

- 클래스 로더 세부 동작  
  a. 로드: 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.  
  b. 검증: 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.  
  c. 준비: 클래스가 필요로 하는 메모리를 할당한다. (필드, 메서드, 인터페이스 등)  
  d. 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.  
  e. 초기화: 클래스 변수들을 적절한 값으로 초기화 한다. (static 필드)

5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다.  
   이 때 실행 엔진은 두 가지 방식으로 변경한다.
   1. 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도는 느리다.
   2. JIT 컴파일러(Just-In-Time Compiler): 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더 이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅 하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일 된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.

## 추상클래스 와 인터페이스의 차이

```
추상 클래스: 상속을 통해서 자손 클래스에서 완성하도록 유도하는 클래스.
```

추상 클래스의 특징

- 미완성 설계도라고도 표현한다.
- 상속을 위한 클래스이기 때문에 따로 객체를 생성할 수 없다.
- class 앞에 abstract 예약어를 사용해야 한다.
- 다중 상속 불가
- 주 용도: 공통으로 필요한 기능들을 여러번 재정의할 필요 없이 사용 가능.

```
인터페이스(Interface): 추상 클래스처럼 다른 클래스 작성하는데 도움을 주는 목적으로 작성한다.
```

인터페이스의 특징

- 기본 설계도라고 할 수 있다.
- 다중 상속이 가능하다.

## 제네릭(Generic) 타입

```
Generic: Java에서의 Generic이란 Data Type을 일반화(Generalize)하는 것을 의미한다. 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.
```

장점

- 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
- 반환 값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

## 직렬화(Serialization)

```
직렬화(Serialization): Java 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 Java 시스템에서도 사용할 수 있도록 Byte 형태로 데이터 변환하는 기술, 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러 이야기 한다.
```

Java와는 다른 형태의 직렬화 방법

- 문자열: CSV(콤마(,) 기준으로 구분), JSON
- 이진: Protocol Buffer 등

왜 Java 직렬화가 필요한가

- 자바 시스템 간의 데이터 교환을 위해 존재함.

자바에서 CSV, JSON 쓰면 안되나?

- 정답은 없다. 목적에 따라 적절하게 사용해야 함.

장점

- Java 시스템 개발에 최적화되어 있다. 복잡한 데이터 구조의 클래스 객체라도 직렬화 기본 조건만 지키면 큰 작업 없이 바로 직렬화가 가능하다. 역직렬화도 마찬가지이다.

## Casting

캐스팅(Casting): 타입 변환

업 캐스팅(Up Casting)

- 서브타입의 인스턴스를 수퍼 타입의 변수로 접근하는 것을 말함.  
  즉, 자식 클래스가 부모 클래스 타입으로 캐스팅 되는 것.  
  이 때, 서브 타입에서는 수퍼 타입에 선언된 필드 혹은 메서드만 접근 가능
- 서브 타입을 수퍼 타입의 변수에 할당하면 자동으로 형변환이 됨.  
  예를 들어 birds class가 있으면 그 상위 클래스인 animal로 할당이 가능하다는 것.
- 거칠게 비유하면 "사람은 동물이다." 정도.

다운 캐스팅(Down Casting)

- 서브 타입 인스턴스를 참조하는 수퍼 타입 변수를 재참조하는 것을 말함.  
  즉, 부모 클래스가 자식 클래스 타입으로 캐스팅되는 것을 뜻함.  
  이 때 강제형변환이 일어나며, 다운 캐스팅한 타입에서 선언된 모든 필드와 메서드에 접근이 가능하다.

## 가비지 컬렉션(Garbage Collection, GC)

Abstract(요약)

- C/C++은 프로그래밍을 할 때 메모리 누수(Leak)를 막기 위해 객체를 생성한 후 사용하지 않는 객체를 프로그래머가 직접 해제 해주어야 했다.
- Java는 JVM이 구성된 JRE(Java Runtime Environment)가 제공되며, 그 구성 요소 중 하나인 Garbage Collection이 자동으로 사용하지 않는 객체를 파괴한다.
- GC에 대해 알기 전에 'stop-the-world'라는 용어를 알아야 한다. 이는 GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는 것이다. 어떤 GC 알고리즘을 써보 'stop-the-world'는 발생하게 되는데, 대게의 경우 GC 튜닝은 이 'stop-the-world' 시간을 줄이는 것이다.

Garbage Collection

- 사용하지 않는 객체를 메모리에서 삭제하는 작업을 뜻한다.
- JVM에서 수행한다.
- JVM의 메모리는 총 5가지 영역(class, stack, heap, native method, PC)로 나뉘는데, GC는 heap 메모리만 다룬다.
- GC의 대상은 일반적으로 다음과 같다.
  1. 객체가 null인 경우 (ex. String str = null)
  2. 블럭 실행 종류 후, 블럭 안에서 생성된 객체
  3. 부모 객체가 null인 경우, 포함하는 자식 객체

GC의 메모리 해제 과정

1. Marking: 많은 시간을 투자해 모든 객체를 스캔하여 메모리가 사용되는지 아닌지를 찾아낸다.
2. Normal Deletion: 참조되지 않는 객체를 제거하고 메모리를 반환한다.
3. Compacting: 성능 향상을 위해 남은 객체(사용 중인 객체)들을 (조각 모음처럼) 묶어서 공간을 최적화를 한다.

## Overloading Overrriding

```
Overloading: 매개 변수의 타입이나 갯수가 다른 이름이 같은 메소드를 만드는 것을 의미한다. 이를 통해 다양한 상황에서 메소드가 호출될 수 있도록 한다. Java의 경우 정적바인딩 한다.
```

```
Overriding: 상위 클래스 혹은 인터페이스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것. Java의 경우는 Overriding 시 동적바인딩 한다.
```

## 클래스, 객체, 인스턴스 개념

```
Class: 객체를 만들어 내기 위한 설계도 혹은 틀이다. 연관되어 있는 변수와 메서드의 집합.
```

```
객체(Object): SW 세계에 구현할 대상이다. 클래스에 선언된 모양 그대로 생성된 실체
```

객체의 특징

- 클래스의 Instance라고도 부른다.
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다
- OOP의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.

```
인스턴스(Instance): 설계도를 바탕으로 SW 세계에 구현된 구체적인 실체. 즉 객체를 SW에 실체화하면 그것을 Instance라고 부른다. 실체화된 Instance는 메모리에 할당된다.
```

인스턴스의 특징

- 인스턴스는 객체에 포함된다.
- OOP의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
- 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다.
- 즉 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
- 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다.

---

# QnA

---

# 참고

[OOP](https://gangnam-americano.tistory.com/15)  
[Java의 특징](https://life-with-coding.tistory.com/430)  
[Java의 컴파일 과정](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Language/%5Bjava%5D%20%EC%9E%90%EB%B0%94%20%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%EA%B3%BC%EC%A0%95.md)  
[추상, 인터페이스](https://myjamong.tistory.com/150)
[Generic](http://tcpschool.com/java/java_generic_concept)  
[Generic 등](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#generic)  
[직렬화](https://devlog-wjdrbs96.tistory.com/268)  
[직렬화2](https://techblog.woowahan.com/2550/)  
[Up/Down Casting](https://viera.tistory.com/3)  
[Garbage Collection](https://github.com/GimunLee/tech-refrigerator/blob/master/Language/JAVA/Garbage%20Collection.md#garbage-collection)  
[Class, Object, Instance](https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html)
