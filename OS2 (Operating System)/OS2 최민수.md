# 프로세스 동기화

경쟁상태(Race Condition), 교착상태(Dead Lock), 세마포어와 뮤택스

## [ 경쟁 상황(Race Condition) ]

```
동시에 여러 개의 프로세스가 동일한 자료를 접근하여 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황
```

- 값이 100인 자료에 A와 B가 동시에 접근할 때, A는 ++를 하고, B는 --을 할 때, 보통은 100-101-100, 100-99-100이 된다고 생각하겠지만 100-101-99이렇게 될 수 있다.

## [ 임계 영역(Critical Section) ]

```
임계 영역(Critical Section): 공유되는 자원, 즉 동시접근하려고 하는 영역(코드 블록)을 말한다.
```

## [ 임계 영역 문제 ]

프로세스들이 Critical Section을 함께 사용할 수 있는 프로토콜을 설계해야 한다.

### 임계 영역 해결을 위한 기본 조건(Requirements)

- Mutual Exclusion(상호 배제)  
  프로세스 P1이 Critical Section에서 실행 중이라면, 다른 프로세스들은 그들이 가진 Critical Section에서 실행될 수 없다.
- Progress(진행)  
  Critical Section에서 실행 중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Critical Section 진입 후보로서 참여될 수 있다.
- Bounded Waiting(한정된 대기)  
  P1이 Critical Section에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 Critical Section에 진입해야하는 횟수는 제한이 있어야 한다.

### 해결책 1. Lock

#### 설명

- HW 기반 해결책
- 동시에 공유 자원에 접근하는 것을 막기 위해 Critical Section에 진입하는 프로세스는 Lock을 획득하고, 빠져나올 때 Lock을 방출함으로써 동시에 접근이 되지 않도록 한다.

#### 한계

- 다중처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.

### 해결책 2. Semaphores

#### 설명: Counting Semaphores

- **가용한 개수**를 가진 자원에 대한 접근 제어용으로 사용되며, 세마포어는 그 가용한 자원의 개수로 초기화된다. 자원을 사용하면 세마포가 감소, 방출하면 세마포가 증가한다.
- 즉 공용 자원을 사용할 수 있는 권리가 여러 개인 것이다.

#### 설명: Binary Semaphores(MUTEX)

- MUTEX, 상호 배제라고도 한다.
- 상호 배제(Mutual Exclusion)의 머릿글자를 따서 만들어졌다.
- 이름 그대로 0과 1사이의 값만 가능하다.
- 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해 사용한다.

#### 단점

- Busy Waiting
  - Critical Section에 진입해야하는 프로세스는 진입 코드를 계속 반복 실행하며 CPU 시간을 낭비하는 것을 Busy Waiting이라고 한다.
  - 특수한 상황이 아니면 비효율적.
  - 일반적으로는 세마포어에서 Critical Section에 진입을 시도했지만 실패한 프로세스에 대해 Block시킨 뒤, Critical Section에 자리가 날 때 다시 깨우는 방식을 사용한다. 이 경우엔 Busy Waiting으로 인한 시간낭비 문제가 해결된다.
- Deadlock(교착 상태)
  - 서로 원하는 자원이 상대에게 있어서 무한정 기다리는 상태.
  - 자세한 것은 하단에 추가 기술

### Mutex와 Semaphore의 차이

- 동기화 대상의 개수
  - Mutex는 동기화 대상이 오직 하나
  - 세마포어는 동기화 대상이 하나 이상
- 세마포어는 Mutex가 될 수 있지만, Mutex는 세마포어가 될 수 없다.
- 세마포어는 소유할 수 없지만, Mutex는 소유 가능하다.

## [ Deadlock ]

### 설명

- 세마포어가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section 진입을 무한정 기다리고 있고, Critical Section 에서 실행되는 프로세스는 진입 대기 중인 프로세스가 실행되어야만 빠져나올 수 잇는 상황.
- 뷔페에서 사과, 바나나를 받고 들어가려는 사람 A, B가 있는데 A는 사과를 담고 있고, B는 바나나를 담고 있다고 할 때, A는 B가 바나나를 그만 담기를 기다리고 있고, B는 A가 사과를 그만 담기를 기다리는, 무한정 기다리는 상황.

### 주로 발생하는 경우

- 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황에서 자원을 요청하고, 그 자원을 사용할 수 없을 때

### Deadlock 발생 조건

4가지 모두 성립해야 Deadlock이 발생한다. (하나라도 성립하지 않으면 Deadlock 문제 해결 가능)

1. **_상호 배제(Mutual Exclusion)_**: 자원은 한 번에 한 프로세스만 사용할 수 있다.
2. **_점유 대기(Hold and Wait)_**: 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함.
3. **_비선점(No Preemption)_**: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.
4. **_순환 대기(Circular Wait)_**: 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

### Deadlick 처리/해결

1. 예방(Prevention)

- 교착 상태 발생 조건 중 하나를 제거하면서 해결한다.
- 자원 낭비가 매우 심하다.
  - 상호 배제 부정: 여러 프로세스가 공유 자원을 사용한다.
  - 점유 대기 부정: 프로세스 실행 전 모든 자원을 할당한다.
  - 비선점 부정: 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반납한다.
  - 순환 대기 부정: 자원에 고유번호를 할당한 후 순서대로 자원을 요구한다. 비효율적이다.

2. 회피(Avoidance)

- 교착 상태 발생 시 피해나가는 방법이다.
- 은행원 알고리즘(Banker's Algorithm)
  - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
  - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
  - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

3. 탐지(Detection)

- 교착 상태가 된 후에 시행하는 방법
- 자원 할당 그래프를 통해 교착 상태를 탐지함
- 자원 요청 시, 탐지 알고리즘을 실행 시켜야 하기 때문에 그에 대한 오버헤드가 발생한다.

4. 회복(Recovery)

- 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당(해당 프로세스를 일시정지 시킴)
- 우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점

## [ Thread-Safe ]

```
Thread-Safe: 멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근할 때, 의도한 대로 동작하는 것
```

### 구현 방법

- 공유 자원에 접근하는 임계 영역(critical section)을 동기화 기법으로 제어해야 한다 => **상호 배제**

- 동기화 기법으로는 Mutex나 Semaphore가 존재

#### 기타 예시

- 남자친구, 여자친구가 공용으로 사용하는 데이트 통장에서 동시에 잔액에 접근하려 할 때

---

# 메모리 관리

메모리, 페이징(Paging), 페이지 교체 알고리즘, 세그먼테이션, 단편화, 가상 메모리, 스레싱

## 메모리 관리가 필요한 배경

- 각각의 프로세스는 독립된 메모리 공간을 갖고, OS 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다.
- OS 만이 OS 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않기 때문

```
Swapping: 메모리의 관리를 위해 사용되는 기법이다. 표준 Swapping 방식으로는 round-robin과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(하드디스크 등)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다. swap에는 큰 디스크 전송 시간이 필요하기 때문에 현재는 메모리 공간이 부족할 때 swapping이 시작된다.
```

```
단편화(Fragmentation): 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데, 이것이 단편화이다.
```

### 단편화의 종류

- 외부 단편화  
  메모리 공간 중 사용하지 못하게 되는 일부분  
  물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생한다.
- 내부 단편화  
  프로세스가 사용하는 메모리 공간에 포함된 남는 부분  
  예를 들어 메모리 분할 자유 공간이 10B 있고 프로세스 A가 9B를 사용하면 1B라는 차이가 존재하고, 이 현상을 내부 단편화라 칭한다.

```
압축: 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한 쪽으로 몰아, 자유 공간을 확보하는 방법론
작업 효율이 좋지 않다.
```

## Paging(페이징)

- 하나의 프로세스가 사용하는 메모리 공간이 연속적이여야 한다는 제약을 없애는 메모리 관리 방법
- 외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론
- 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.
- 하나의 프로세스가 사용하는 공간은 (논리 메모리에서) 여러 개의 페이지로 나뉘어 관리되고, 개별 페이지는 순서에 상관없이 물리 메모리에 있는 Frame에 Mapping되어 저장된다.
- 장점
  - 페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요 없이 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있다.
  - 메모리 할당이 쉽다
  - swap이 쉽다.
- 단점
  - 내부 단편화 문제의 비중이 늘어난다. 프로세스가 1001B를 요구하고, 페이지가 1000B 단위이면 2번째 페이지는 1B만을 사용하고 999B를 버리게 된다.
  - context switch할 때마다 연산이 많이 들어간다
  - page 개수가 너무 많아서 table이 크다.

## Segmentation(세그멘테이션)

- 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록에 담지 않고, 서로 다른 크기의 논리적 단위인 Segment로 분할한다.
- 사용자가 두 개의 주소(세그먼트 번호 + 변위)로 지정한다.
- 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장한다.
- 장점
  - 연속적일 필요가 없다
  - 공유가 가능하다
  - swap할 때 모든 segment가 나갈 필요가 없다.
- 단점
  - 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수 있다. 즉, 외부 단편화가 발생한다.
  - 메모리 할당이 복잡함

## 가상 메모리

- 다중 프로그래밍을 실현하기 위해선 많은 프로세스들을 동시에 메모리에 올려두어야 한다.
- 가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.
- 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다. (과거엔 실행되는 코드의 전부를 물리 메모리에 존재시켜야만 실행이 가능했다)

### 프로그램의 일부분만 메모리에 올릴 수 있다면

- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 응답 시간은 유지되고, CPU 이용률과 처리율은 높아진다.
- swap에 필요한 입출력이 줄어들어 프로그램들이 빠르게 실행된다.

### 가상 메모리가 하는 일

- 가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다.
- 이로써 작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공할 수 있다.

### 가상 주소 공간

- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다.
- 프로세스가 요구하는 메모리 공간을 가상 메모리에서 제공함으로서 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.

### 프로세스 간의 페이지 공유: 가상 메모리의 역할

- 시스템 라이브러리가 여러 프로세스들 사이에 공유될 수 있도록 한다.
- 각 프로세스들은 공유 라이브러리를 자신의 가상 주소 공간에 두고 사용하는 것처럼 인식하지만, 라이브러리가 올라가 있는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.
- 프로세스들이 메모리를 공유하는 것을 가능하게 한다.
- 프로세스들은 공유 메모리를 통해 통신할 수 있다.
- 각 프로세스들은 각자 자신의 주소 공간처럼 인식하지만, 실제 물리 메모리는 공유되고 있다.
- fork()를 통한 프로세스 생성 과정에서 페이지들이 공유되는 것을 가능하게 한다.

### Demand Paging(요구 페이징)

- 프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들한 적재하는 전략을 말한다.
- 가상 메모리 시스템에서 많이 사용된다.
- 그리고 가상 메모리는 대개 페이지로 관리된다.
- 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다.
- 한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.
- 프로세스 내의 개별 페이지들은 페이저(Pager)에 의해 관리된다.
- Pager는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옴으로서, 사용되지 않을 페이지를 가져오는 시간/메모리 낭비를 줄인다.
- 절약한 메모리로 다른 process를 multi tasking 할 수 있다.

```
페이지 부재(Page Fault): 물리 메모리에 있지 않은 페이지에 접근하려 할 때 유발된다. 시스템의 종류에 따라 약간 다를 수 있으나, 대체로는 빈 페이지가 하나도 없거나, 미리 정한 수보다 적을 때 발생한다.
```

### 페이지 교체(Page Replacement)

- 프로세스 동작에 필요한 페이지를 요청하는 과정에서 Page Fault가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다.
- 하지만 물리 메모리가 모두 사용 중인 상황이라면, 페이지 교체가 이루어져야 한다.
- (또는 OS가 프로세스를 강제 종료 시킨다)

#### 페이지 교체 기본적인 방법

물리 메모리가 모두 사용 중인 상황에서의 메모리 교체 흐름.

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
   1. 페이지 교체 알고리즘을 통해 희생될 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

## 페이지 교체 알고리즘

### 1. FIFO 페이지 교체

- First In First Out
- 장점  
  이해하기 쉽고, 프로그래밍하기도 쉽다
- 단점  
  오래된 페이지가 불필요한 정보를 포함할 수 있다. (초기 변수 등)  
  처음부터 활발하게 사용되는 페이지를 교체하여 페이지 부재율을 높일 수 있다
  - belady의 모순 발생 가능

```
belady의 모순: 페이지를 저장할 수 있는 페이지 프레임의 개수를 늘려도 되려 페이지 부재가 더 많이 발생하는 모순이 존재한다.
```

### 2. 최적 페이지 교체(Optimal Page Replacement)

- 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.
- 장점  
  알고리즘 중 가장 낮은 페이지 부재율을 보장한다
- 단점
  구현이 어렵다. 모든 프로세스의 메모리 참조의 계획을 미리 파악할 방법이 없기 때문이다.

### 3. LRU 페이지 교체(Least-Recently-Used)

- 가장 오랫동안 사용되지 않은 페이지를 찾아 교체한다.
- 대체적으로 FIFO보단 우수하고, 최적보단 떨어진다

### 4. LFU 페이지 교체(Least Frequently Used)

- 참조 횟수가 가장 적은 페이지를 교체한다. 많이 참조한 페이지는 남긴다.
- 어떤 프로세스가 특정 페이지를 집중적으로 사용한 후 다른 기능을 사용한다고 할 때, 더 이상 사용하지 않음에도 지속적으로 메모리에 머무는 경우가 있다.
- 최적 페이지 교체를 잘 근사하지 못해 잘 쓰이지 않는다.

### 5. MFU 페이지 교체(Most Frequently Used)

- 참조 회수가 작장 적은 페이지가 최근에 메모리에 올라왔고, 앞으로 게속 사용될 것이라는 가정에 기반함
- 최적을 잘 근사하지 못해 잘 쓰이지 않는다.

## 쓰레싱

- 프로세스의 처리시간보다 페이지 교체 시간이 더 많아지는 현상

- 원인  
  다중 프로그램의 정도가 너무 높아(너무 많은 프로세스가 적재되어) 프로세스가 프레임을 충분히 할당받지 못해 페이지 부재가 발생한다.  
  활발하게 사용되는 페이지들을 모두 적재하지 못해 교체되는 즉시 바로 필요해지게 되고, 곧바로 읽어 들어야 할 페이지를 연속적으로 교체하게 되며 발생한다.

- 해결 방법
  1. 다중 프로그램 정도를 낮춘다
  2. 패이지 부재율을 조절한다
  3. Working Set을 유지한다.
  4. 프로세스가 필요로 하는 만큼 프레임을 제공
  5. 일부 프로세스를 종료

```
Working Set(작업 집합): 지역성을 토대로 프로세스가 일정시간동안 원활하게 수행되기 위해 메모리에 한꺼번에 올라가야하는 페이지들의 집합.
쉽게 말하면 스레싱을 방지하기 위해 주 메모리에 있어야 하는 페이지 모음이다. 개념적인 개념으로 실제론 알 수 없다.
```

---

# 예상 문제(스터디에 출제할 것)

## 문제 1

가상 메모리와 Page Fault를 관계지어 설명해보세요

### 답변

가상 메모리는 가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법이다.  
Page Fault는 앞선 가상 메모리 활용으로 인해 일부 페이지는 물리 메모리에 올라가 있지 않은데, 그 때 물리 메모리에 있지 않은 페이지에 접근하려 할 때 유발된다.

## 문제 2

Critical Section과 Deadlock에 대해 설명해보라

### 답변

Critical Section은 공유 되는 부분, 즉 여러 프로세스가 동시에 접근할 수 있는 코드 영역입니다.

Deadlock은 예를 들어 설명하자면 A가 Printer를 잡은 상태에서 disk에 접근하려하고, B가 disk를 잡은 상태에서 printer에 접근하려 하면, 서로 무한정 기다리는 상태에서 벗어날 수 없는 것을 말합니다.

## 문제 3

페이지 교체를 하는 간단한 방법을 말로 풀어서 설명해보세요.

### 답변

1. 디스크에서 필요한 페이지의 위치를 찾는다.
2. 빈 페이지 프레임을 찾는다.
   1. 페이지 교체 알고리즘을 통해 희생될 페이지를 고른다.
   2. 희생될 페이지를 디스크에 기록하고, 관련 페이지 테이블을 수정한다.
3. 새롭게 비워진 페이지 테이블 내 프레임에 새 페이지를 읽어오고, 프레임 테이블을 수정한다.
4. 사용자 프로세스 재시작

## 문제 4

Paging과 Segmentation이 생기게 된 원인이 무엇입니까? 무엇을 해결하기 위해 등장했습니까?

### 답변

메모리 단편화를 해결하기 위해서 개발되었습니다.
메모리 단편화란 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유 공간들이 늘어나게 되는데, 이것이 단편화이다.

외부 단편화
메모리 공간 중 사용하지 못하게 되는 일부분
물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 분산되어 있을 때 발생한다.
내부 단편화
프로세스가 사용하는 메모리 공간에 포함된 남는 부분
예를 들어 메모리 분할 자유 공간이 10B 있고 프로세스 A가 9B를 사용하면 1B라는 차이가 존재하고, 이 현상을 내부 단편화라 칭한다.

외부 단편화 문제를 페이징이, 내부 단편화 문제를 segmentation이 해결할 수 있습니다.

# 예상 문제(자주 나오는 것)

Q. 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.

Q. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.

Q. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.  
A1. n명이 앉을 수 있는 테이블에서 철학자를 n-1명만 앉힘  
A2. 한 철학자가 젓가락 두개를 모두 집을 수 있는 상황에서만 젓가락 집도록 허용  
A3. 누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용

Q. 페이지 교체 알고리즘에 대해 설명

Q. 메모리 단편화에 대해 설명

Q. 페이징과 세그먼테이션

---

## 참고

[[CS 정리] 운영체제 (1)](https://girawhale.tistory.com/61?category=948070)  
[👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/operating-system/Memory.html)  
[임계영역의 정의](https://jhnyang.tistory.com/36?categ]ory=815411)  
[내부/외부 단편화](https://m.blog.naver.com/rbdi3222/220623825770)  
[대학교 필기한 것]  
[IT 면접 단골 질문](https://medium.com/@Aaron__Kim/%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-db-os-nw-e03cdfe07966)  
[OS 기출](https://hello-cruiser.tistory.com/entry/4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B8%B0%EC%B6%9C-%ED%95%B5%EC%8B%AC-%EC%9D%91%EC%9A%A9)
