# Network 심화 및 기술들

---

# 대칭키 공개키

## 대칭키

```
대칭키: 암복화에 같은 암호 키를 쓰는 알고리즘. 암호화를 하는 측과 복호화를 하는 측이 같은 암호 키를 공유해야 한다.
```

장점

- 공개키 암호화 방식에 비해 속도가 빠르다.

단점

- 키 배송 문제가 발생
- 키 교환 중 키가 탈취될 수 있다.
- 사람이 증가할 수록 관리해야할 키가 방대하게 많아진다 (따로따로 키교환을 해야하기 때문)

대표 알고리즘: DES, 3DES, AES, SEED, ARIA 등

## 공개키

```
공개키(비대칭키) 암호화 방식: 암복호화에 사용하는 키가 서로 다른 암호화 방식. 사전에 비밀 키를 나눠가지지 않은 사용자들이 안전하게 통신할 수 있도록 하는 알고리즘. 공개 키는 누구나 알 수 있지만 그에 대응하는 비밀 키(개인 키)는 키의 소유자만이 알 수 있어야 한다.
```

장점

- 키 분배 필요가 없다
- 기밀성/인증/부인방지 기능을 제공한다

단점

- 대칭키 암호화 방식에 비해 속도가 느리다

대표 알고리즘: PKI, RSA, ECC

### 공개 키 암호 방식의 종류

1. 공개 키 암호: 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어볼 수 있다.

- 공개키 용도: 평문을 암호화. 상대 공개키로 암호화해서 보냄
- 비밀키 용도: 암호문을 복호화하기 위한 것

2. 공개 키 서명: 특정한 비밀 키로 만들었다는 것을 누구나 확인할 수 있다.

- 공개키 용도: 서명이 올바른지 검증하기 위한 것
- 비밀키 용도: 평문을 사용하여 서명하기 위한 것

# HTTPS가 SSL 인증서를 이용하여 보안통신을 진행하는 과정

![SSL 통신 과정](https://i.imgur.com/YIfy1wK.png)
이건 잘 정리된 것을 못찾음.

# 부하분산(로드밸런싱)

```
부하분한(Load Balancing): 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것. 서버에 가해지는 부하(Load)를 분산(Balancing)하는 것이다.
```

## 부하 분산이 필요한 이유

사업의 규모가 확장되고 클라이언트의 수가 늘어나면(=트래픽이 증가하면) 기존 서버만으로는 정상적인 서비스가 불가능하다.  
이를 해결하기 위해 2가지 방법이 있다.

- Scale Up: 서버 자체의 성능을 높이는 것
- Scale Out: 여러 대의 서버를 두는 것

여기서 부하 분산은 Scale-Out에 해당한다

## 부하 분산 알고리즘

1. 라운드 로빈

- 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
- 서버와의 연결이 오래 지속되지 않는 경우 적합

2. 가중 라운드로빈

- 각 서버에 가중치를 매기고 가중치가 높은 서버에 우선적으로 배정하는 방식
- 서버의 트래픽 처리 능력이 다른 경우 적합

3. 최소 연결

- 요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 트래픽을 배정하는 방식
- 서버에 분배된 트래픽들이 일정하지 않은 경우에 적합

4. IP 해시

- 클라이언트의 IP주소를 특정 서버로 매핑하여 요청을 처리하는 방식
- 사용자가 항상 동일한 서버로 연결됨

## L4 vs L7

### L4 부하 분산

- 전송(Transport) 계층에서 로드를 분산한다
- TCP, UDP 포트 정보를 바탕으로 한다
- 데이터 안을 보지 않고 패킷 레벨에서만 부하를 분산하기 때문에 속도가 빠르고 효율이 높다
- 섬세한 라우팅이 불가능하지만 L7 보다 저렴하다

### L7 부하 분산

- 응용(Application) 계층에서 부하를 분산한다
- HTTP 헤더, 쿠키 등과 같은 사용자 요청을 기준으로 특정 서버에 트래픽을 분산하는 것이 가능하다. 즉, 패킷 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능하다. 특정 기능을 하는 요청이 들어오면 그 요청을 처리하는 서버로 보내는 식으로 동작한다.
- 더 섬세한 라우팅이 가능하고, 비정상적인 트래픽을 필터링할 수 있다.
- 패킷의 내용을 복호화해야 하기 때문에 더 많은 비용이 든다.

# 동기/비동기 & 블로킹/논블로킹

## 동기/비동기(Synchronous/Asynchronous)

처리해야 할 작업들을 어떠한 '흐름'으로 처리할 것인가에 대한 관점

- 동기: 작업을 수행하는 두 개 이상의 주체가 서로 동시에 수행하거나, 동시에 끝나거나, 끝나는 동시에 시작할 때를 의미함
- 비동기: 두 주체가 서로의 시작, 종료시간과는 관계 없이 별도의 수행 시작/종료 시간을 가지고 있을 때

## 블로킹/논블로킹

처리되어야 하는 (하나의) 작업이, 전체적인 작업 '흐름'을 막느냐 안막느냐에 대한 관점.

- 블로킹: 자신의 작업을 하다가 다른 작업 주체가 하는 작업의 시작부터 끝까지 기다렸다가 다시 자신의 작업을 시작하는 경우
- 논블로킹: 다른 주체의 작업과 관계없이 자신의 작업을 계속하는 경우

## 예시

동기 + 블로킹: 빨래, 설거지, 청소를 한다면, 빨래를 마치고 설거지를 마치고 청소를 한다
비동기 + 논블로킹: 외부 대행 업체를 이용해서 각각 빨래, 설거지, 청소를 맡기고, 나는 다른 일을 하면서 완료 보고를 기다린다.

# 브라우저에 naver.com을 치면 일어나는 일들

# Frame, Packet, Segment, Datagram

Payload(보내고 싶은 data)는 동일한데 헤더 정보가 다르다. 어떤 OSI 계층에서 encapsulation 됐냐의 차이이다.  
1 segment = 1 packet = 1 frame

Datagram은 사용자의 순수한 message를 다르게 부르는 말이다. (UDP에서의 데이터 전송 단위라고도 하는데 정확한 정보??)

- Transport Layer: Segment(발신지, 목적지 포트, 오류 검출 코드 등이 추가됨)
- Network Layer: Packet(발신지, 목적지 주소 등이 추가됨)
- Data Link Layer: Frame

# DNS Round Robin

서버에 요청을 보낼 때 DNS에 서버의 IP를 요청한다는 점에 착안하여 만들어진 방법

## 동작

1. 클라이언트가 어떤 요청을 보내기 위해선 DNS에 서버의 IP를 먼저 요청해야 한다.
2. 이러한 요청이 들어올 때 DNS에서 각 서비스의 서버에 해당하는 IP를 RR 방식으로 제공하는 방법

## 장점

- 중간 장비(로드 밸런서)가 없어도 서비스가 가능하다
- 따라서 비용적인 부분이 줄어든다
- 간편하다

## 단점

- 서버에 장애 발생 시 감지가 힘들다
- 부하의 분산이 고르지 않다(로드 밸런서가 없기 때문)
- 서버에 이상이 있어도 부하를 분산 시킨다
- DNS 결과를 Caching 하기 때문에 균등한 분산이 어렵다.

## 대안: GSLB(Global Server Load Balancing)

- 기존의 Round Robin DNS는 health check(어플리케이션이 정상적으로 동작하는지 확인하는 행위) 기능이 없어 목록에 있는 주소 중 하나의 서비스가 실패해도 여전히 해당 주소를 제공하고, 클라이언트는 작동 불가능한 서비스에 도달하려고 시도한다.
- 등록된 호스트에게 주기적으로 health check을 수행함
- 네트워크의 거리 혹은 지역에 따라 주기적으로 성능을 측정하고 결과를 저장하여 DNS 쿼리 시 지리적, 네트워크 거리가 가까운 서버를 반환한다.

# OAuth

```
OAuth: 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.
```

## 배경

- 3rd party application에 id와 pw를 제공하고 싶지 않다. (구글보단 위험하니까)

## (2.0 기준) 설명

- https가 필수이고, 암호화를 https에 맡긴다
- 다양한 인증 방식을 지원한다.

## 인증 방법

1. 접속하려는 Client 는 Resource Provider 에게 id 와 secret 값을 요청한다. 그 값을 Client 는 저장을 해두고 후에 인증 시에 사용한다.
2. Client 가 Resource Provider 에게 접속을 위한 Request Token 을 user 데이터와 함께 요청하면 Resource Provider는 Request Token 을 발급해준다.
3. Client 가 user 에게 인증을 요청한 본인이 맞는지 인증페이지를 통해 확인을 한다.
4. user 가 해당페이지를 로그인을 하여 본인임을 증명하고 Resource Provider는 Client 가 로그인을 할 수있도록 권한을 수락한다.
5. Client 는 user 가 권한을 수락하여 얻은 code 와 처음에 받은 id, secret 값을 Resource Provider 에게 전달한다.
6. 전달된 정보들이 유효하면 Resource Provider 는 Client에게 Access Token을 발급해준다.
7. Client는 Access Token을 이용하여 Resource Provider 정보로 로그인을 하게된다.

## 활용 사례

별도의 회원가입 없이 다른 플랫폼 아이디로 로그인할 수 있는 서비스

# 웹소켓 vs TCP/IP 소켓 차이점

```
소켓: 프로그램이 네트워크 상에서 데이터 송신, 수신을 하기 위한 연결부
```

- TCP/IP 소켓이 과일이라면, 웹 소켓은 사과이다. 즉 웹 소켓은 TCP/IP 소켓의 일부이다.

# URI VS URL VS URN

```
통합 자원 식별자(URI, Uniform Resource Identifier): 인터넷의 우편물 주소 같은 것. 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다. URI에는 두 가지 형태가 있는데 이것이  URL, URN이다.
```

```
통합 자원 지시자(URL, Uniform Resource Locator): URI의 가장 흔한 형태이다. 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.
```

예시

- 네이버의 URL: http://naver.com
- 네이버 뉴스에서 분류 중 "세계" 주제의 기사에 대한 URL: http://news.naver.com/main/main.nhn?mode=LSD&mid=shm&sid1=104
  한계
- URL은 주소이지 실제 이름이 아니다. 이는 특정 시점에 어떤 것이 위치한 곳을 알려줌
- 예를 들어, 구글 검색에 a.com/62가 노출되었는데 내가 a.com/test/62로 바꾸면 다른 사람이 해당 검색을 했을 때 페이지를 찾을 수 없게 된다.
- 따라서 이를 해결하기 위해 객체의 위치와 관계없이 그 객체를 가리키는 실제 객체의 이름을 사용하는 것이다.

```
URN(Uniform Resource Name): 콘텐츠를 이루는 한 리소스에 대해 그 리소스에 영향 받지 않는 유일무이한 이름 역할을 한다.
```

# HTTP 1.0 VS HTTP 2.0

```
HTTP: 웹 상에서 클라이언트와 웹 서버 간 통신을 위한 프로토콜 중 하나
```

## HTTP 1.1이 느린 이유

1. 연결 당 하나의 요청과 응답을 처리하기 때문에 동시 전송 문제와 다수의 리소스를 처리하기에 속도와 성능 이슈가 존재
2. HOL(Head Of Line) Blocking (특정 응답 지연): HTTP 1.1의 사양 상의 제한으로 클라이언트와 리퀘스트의 순서와 서버의 응답 순서는 동기화해야 됨
3. RTT(Round Trip Time) 증가 => 양방향 지연
4. (특히 쿠키 때문에) 헤더가 크다 -> 웹 페이지 방문시 다수의 HTTP 요청이 있고, 매 요청마다 중복된 헤더 값을 전송함.

## HTTP 2.0이 빠른 이유

1. Multiplexed Streams(한 커넥션에 여러 개의 메세지를 동시에 주고 받을 수 있다)
2. 요청이 커넥션 상에서 다중화 되므로 HOL Blocking이 발생하지 않음
3. Stream Prioritization (요청 리소스 간 의존 관계를 설정)
4. Header Compression (Header 정보를 HPACK 압축 방식을 이용하여 압축 전송)
5. Server Push(HTML 문서 상에 필요한 리소스를 클라이언트 요청 없이 보내줄 수 있음)
6. 프로토콜 협상 매커니즘 - 프로토콜 선택. ex) HTTP 1.1 or 2.0 or etc
7. HTTP 1.1과의 높은 수준의 호환성 - 메소드, 상태 코드, URI 및 헤더 필드
8. 페이지 로딩 속도 향상

---

# QnA

Q1. 공개키를 활용한 암호, 공개키를 활용한 서명에 대해 설명하라
A1.

1. 공개 키 암호: 특정한 비밀 키를 가지고 있는 사용자만 내용을 열어볼 수 있다.

- 공개키 용도: 평문을 암호화. 상대 공개키로 암호화해서 보냄
- 비밀키 용도: 암호문을 복호화하기 위한 것

2. 공개 키 서명: 특정한 비밀 키로 만들었다는 것을 누구나 확인할 수 있다.

- 공개키 용도: 서명이 올바른지 검증하기 위한 것
- 비밀키 용도: 평문을 사용하여 서명하기 위한 것

Q2. 부하 분산(로드 밸런싱)의 개념과 그것이 필요한 이유에 대해 설명하라
A2.
개념: 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것. 서버에 가해지는 부하(Load)를 분산(Balancing)하는 것이다.
이유: 트래픽 증가에 따른 Scale-out의 필요성. 로드 밸런싱은 그 종류 중 하나

Q3. DNS Round Robin의 개념과 그 장점에 대해 설명하시오
A3.
개념: 서버에 요청을 보낼 때 DNS에 서버의 IP를 요청한다는 점에 착안하여 만들어진 방법

Q. URI, URL, URN 에 대해 설명

## 동작

1. 클라이언트가 어떤 요청을 보내기 위해선 DNS에 서버의 IP를 먼저 요청해야 한다.
2. 이러한 요청이 들어올 때 DNS에서 각 서비스의 서버에 해당하는 IP를 RR 방식으로 제공하는 방법
   장점:

- 중간 장비(로드 밸런서)가 없어도 서비스가 가능하다
- 따라서 비용적인 부분이 줄어든다
- 간편하다

---

최민수 꼬리 질문 목록

1. 대칭키에 어떤 문제 -> 공개키는 그 문제를 어떻게 해결했나
2. HTTP 2.0에 단점은 없나?
3. URL, URN 예시 가능할까요
4. CA의 단점을 극복하기 위한 신기술? A. 블록체인
5. DNS RR의 단점을 극복하기 위한 방안은?

- ***

나에 대한 피드백
공부해라

---

# 참고

[대칭키&비대칭키](https://liveyourit.tistory.com/183)  
[대칭키 wiki](https://ko.wikipedia.org/wiki/%EB%8C%80%EC%B9%AD_%ED%82%A4_%EC%95%94%ED%98%B8)  
[비대칭키 wiki](https://ko.wikipedia.org/wiki/%EA%B3%B5%EA%B0%9C_%ED%82%A4_%EC%95%94%ED%98%B8_%EB%B0%A9%EC%8B%9D)  
[SSL 동작방법](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)  
[SSL 통신과정](https://it-sunny-333.tistory.com/144)  
[부하분산 wiki](https://ko.wikipedia.org/wiki/%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0)  
[부하분산 설명](https://velog.io/@jisoo1170/Load-Balancing%EC%9D%B4%EB%9E%80)  
[동기 비동기 예시](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%9D%98-%EC%B0%A8%EC%9D%B4)  
[동기 비동기 설명](https://deveric.tistory.com/99)  
[Packet, Segment](https://velog.io/@hidaehyunlee/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%ED%8C%A8%ED%82%B7-%ED%97%B7%EA%B0%88%EB%A6%B4-%EB%95%90-PDU%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)  
[DNS Round Robin 1](https://velog.io/@dbstjrwnekd/DNS-Round-Robin)  
[DNS Round Robin 2](https://judo0179.tistory.com/127)  
[OAuth wiki](https://ko.wikipedia.org/wiki/OAuth)  
[OAuth란](https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)  
[OAuth 인증방법](https://sarc.io/index.php/miscellaneous/1796-oauth)  
[URI & URL & URN](https://mygumi.tistory.com/139)  
[HTTP 1.1 & HTTP 2.0](https://goldfishhead.tistory.com/26)
